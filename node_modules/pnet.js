(function () {

  function PNet () {
    var gPetriNet = {
      places: {},
      transitions: {},
      arcs: {},
    };

    var gMap = {
      count: {
        arc: 0,
        transition: 0,
        place: 0,
      },
      context: {},
    };

    return {
      Scopes,
      Arc,
      Declaration,
      Place,
      Transition,
      Sequence,
    }

    ///// Prototypes /////
    function _init() {
      // TODO
    }

    function Scopes(scopes) {
      var Scopes = {
        compile,
        check,
        exe,
        type: "Scopes",
      };

      onCreate(scopes);
      return Scopes;

      function onCreate(scopes) {
        Scopes.scopes = scopes;
      }

      function compile() {
        var scope = Scopes.scopes;
        while(scope !== null) {
          scope.val.compile();
          scope = scope.next;
        }
      }

      function check() {
        console.log(gMap);
      }

      function exe() {
        return gPetriNet;
      }
    }

    function Arc(sourceId, targetId, weight) {
      var Arc = {
        compile,
        check,
        type: "Arc",
      };

      var _typeSource;
      var _typeTarget;
      var _source;
      var _target;

      onCreate(sourceId, targetId, weight);
      return Arc;

      function onCreate(sourceId, targetId, weight) {
        gMap.count.arc += 1;
        Arc.key = "arc"+gMap.count.arc;

        if(!gMap.context[sourceId])
          throw sourceId + " is not defined";
        Arc.sourceId = sourceId;
        _source = gMap.context[sourceId].func;

        if(!gMap.context[targetId])
          throw targetId + " is not defined";
        Arc.targetId = targetId;
        _target = gMap.context[targetId].func;

        _typeSource = gMap.context[sourceId].func.type;
        _typeTarget = gMap.context[targetId].func.type
        if(_typeSource === _typeTarget)
          throw "You can not connect two " + _typeSource;

        Arc.value = weight;
      }

      function compile() {
        gPetriNet.arcs[Arc.key] = {
          sourceId: _source.key,
          targetId: _target.key,
          value: weight
        };

        if(_typeSource === "Transition") {
          _source.outputs.push(_target.key);
        } else {
          _target.inputs.push(_source.key);
        }
      }

      function check() {
        
      }
    }
    
    function Declaration(id, func) {
      var Declaration = {
        compile,
        check,
        type: "Declaration",
      };
      onCreate();
      return Declaration;

      function onCreate() {
        Declaration.id = id;
        Declaration.func = func;

        if(gMap.context[id]) {
          throw id + " already exists";
        }
        gMap.context[id] = {
          func,
          key: func.key
        };

      }

      function compile() {
        Declaration.func.compile();
      }

      function check() {
        
      }
    }

    function Place (token, label) {
      var Place = {
        compile,
        check,
        type: "Place",
      };

      onCreate(token, label);
      return Place;

      function onCreate(token, label) {
        gMap.count.place += 1;
        Place.key = "p"+gMap.count.place;

        Place.token = parseInt(token);
        Place.label = label;
      }

      function compile() {
        gPetriNet.places[Place.key] = {
          tokens: Place.token,
          label: Place.label
        }
      }

      function check() {
        
      }
    }

    function Transition(label) {
      var Transition = {
        compile,
        check,
        type: "Transition",
      };

      onCreate(label);
      return Transition;
      
      function onCreate(label) {
        gMap.count.transition += 1;
        Transition.key = "t"+gMap.count.transition;

        Transition.label = label;
        Transition.inputs = [];
        Transition.outputs = [];
      }

      function compile() {
        gPetriNet.transitions[Transition.key] = {
          inputs: Transition.inputs,
          outputs: Transition.outputs,
          label: Transition.label
        }
      }

      function check() {
        
      }
    }

    function Sequence(length, init) {
      var Sequence = {
        compile,
        check,
        type: "Sequence",
      };

      var _net = {
        places: {},
        transitions: {},
        arcs: {}
      };

      onCreate();
      return Sequence;
      
      function onCreate() {
        Sequence.length = length;
        Sequence.init = init;
        

      }

      function compile() {

      }

      function check() {
        
      }
    }

  }

  module.exports = PNet();

})();